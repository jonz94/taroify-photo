<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Change Green to Purple</title>
    <style>
      #drop-area {
        width: 100%;
        height: 300px;
        border: 2px dashed #ccc;
        border-radius: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 20px 0;
        font-size: 20px;
        color: #777;
      }
      #drop-area.dragover {
        background-color: #f0f0f0;
        border-color: #666;
        color: #333;
      }
    </style>
  </head>
  <body>
    <h1>Upload or Drag and Drop Image to Change Green to Purple</h1>

    <!-- File Input -->
    <input type="file" id="upload" accept="image/*" />
    <br /><br />

    <!-- Drag-and-drop area -->
    <div id="drop-area">Drag & Drop Image Here</div>

    <!-- Image Output -->
    <img
      id="output-image"
      alt="Processed Image"
      style="display: none; max-width: 100%; margin-top: 20px"
    />

    <!-- Hidden Canvas for Processing -->
    <canvas id="canvas" style="display: none"></canvas>

    <script>
      const dropArea = document.getElementById('drop-area');
      const fileInput = document.getElementById('upload');
      const canvas = document.getElementById('canvas');
      const outputImage = document.getElementById('output-image');
      const ctx = canvas.getContext('2d');

      // Prevent default drag behaviors globally (for the whole document)
      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach((eventName) => {
        document.addEventListener(eventName, preventDefaults, false);
      });

      // Highlight drop area when item is dragged over it
      ['dragenter', 'dragover'].forEach((eventName) => {
        dropArea.addEventListener(
          eventName,
          () => dropArea.classList.add('dragover'),
          false,
        );
      });

      ['dragleave', 'drop'].forEach((eventName) => {
        dropArea.addEventListener(
          eventName,
          () => dropArea.classList.remove('dragover'),
          false,
        );
      });

      // Handle dropped files in the drop area
      dropArea.addEventListener('drop', handleDrop, false);

      // Handle file input selection
      fileInput.addEventListener('change', function (e) {
        const file = e.target.files[0];
        if (file && file.type.startsWith('image/')) {
          handleImage(file);
        }
      });

      // Prevent default behavior for drag and drop events
      function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
      }

      // Handle the file dropped in the drop area
      function handleDrop(e) {
        const dt = e.dataTransfer;
        const file = dt.files[0];
        if (file && file.type.startsWith('image/')) {
          handleImage(file);
        } else {
          alert('Please drop an image file.');
        }
      }

      // Process and display the image as an <img> element
      function handleImage(file) {
        const reader = new FileReader();
        const img = new Image();

        reader.onload = function (e) {
          img.src = e.target.result;
        };

        img.onload = function () {
          // Set canvas dimensions to match the uploaded image
          canvas.width = img.width;
          canvas.height = img.height;

          // Draw the image onto the hidden canvas
          ctx.drawImage(img, 0, 0);

          // Get the image's pixel data
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const data = imageData.data;

          // Loop through each pixel, detecting green and converting it to purple
          for (let i = 0; i < data.length; i += 4) {
            const r = data[i]; // Red
            const g = data[i + 1]; // Green
            const b = data[i + 2]; // Blue

            // Detect green color: We can consider a pixel "green" if the green channel is significantly higher than red and blue
            if (g > 50 && g > r + 1 && g > b + 1) {
              // Convert green to purple
              data[i] = g; // New Red value (increase red)
              data[i + 1] = g / 2; // Set green channel to g/2 (to reduce green)
              data[i + 2] = g; // New Blue value (increase blue for purple tone)
            }
          }

          // Update the canvas with the modified pixel data
          ctx.putImageData(imageData, 0, 0);

          // Convert the canvas to a data URL and display it as an <img>
          const dataURL = canvas.toDataURL('image/png');
          outputImage.src = dataURL;
          outputImage.style.display = 'block'; // Show the processed image
        };

        // Read the selected image file
        reader.readAsDataURL(file);
      }
    </script>
  </body>
</html>
